
This is a description of the next and next-next generation of to be
implemented features.

There is no exact time line because the amount of time spend for this
tools changes from time to time (depending on many factors).  From
history it may be assumed that it takes about 6 to 8 weeks from one
version to the next.

Also the version number shown here might change: if there are other
requests from customers this will be done first.  Also it might be
that from time to time there is a bug-fix release of rmtoo.

The history of this file, i. e. the already implemented features can
be found the appropriate release notes.

There are some major aim to go for:
o Get rmtoo listed in the INCOSE tool survey.
o Get rmtoo added to at least one Linux distribution (preferred
  Debian)

IMPORTANT
=========
o Add requirements from Roadmap.
o Rethink about the modules: they should also run (at least partially)
  for the topic based output.  Is there a way to unify this?

v14
===
o Emacs mode for editing topic (tic) files.
  (This is needed for colorful presentation)
o Create an example project which can
  be used for fast first results

v15
===
o finish / write all lost man-pages, e.g.:
  - Man pages for configuration of output modules
    + graph
  - Man page for template project
o Update presentation:
  - Add section about topics
    (Adapt latex output)
  - Add HTML-Output
  - Rewrite graph output
  - Add graph2 output
  - Add code analyze 
    + count in / out
    + topic count
    + word-checking
  - Pricing feature (including creating a graph from the cvs file)
  - version feature
  - Introduction of latex document in the presentation
  - template project

v16
===
o Increase test case coverage to minimum 90%
o Add test cases for rmtoo-pricing-graph

v17
===
o Add new paragraphs from rmtoo.7 to the presentation.
o Add '10 Gründe rmtoo zu nutzen'
o Add '10 Gründe rmtoo nicht zu nutzen'
o Add '10 Ausreden wieso Ihr Projekt kein Req Mgmt verwendet'
o Include sub-graphs in the PDF and HTML documentation
  - Topic based (all reqs of a topic)
  - req based (all reqs dependend and depend on one req)
o Adapt man pages
o Adapt presentation


==> This will be the point of time to get rmtoo into one Linux
    distribution and send out the form to INCOSE.


OTHER / LATER
=============
o Long Term Evolution: It's all about data storage and who (which
  program) can access (read, write, change, ...) which data.
  - Write requirements
  - Discuss with other projects (ganttproject, freemind, ...)
  - Storage vs. Bus-System
  - Verfügbarkeit
  - Ausfallsicherheit
  - Colaboration
  - Concurrency
o Add makefile dependencies: .rmtoo_dependencies depends
  on the ConfigX.py file.
o output level in 'prios.py' must be configurable
o traceability of changes
  - Dependent on changes: list all depended requirements which must
    be checked.
o Add change marks for at last latex output:
  - specify one additional version number from which the difference is
    made
  - Mark
    + Additions
    + Changes
    + Deletions
    (Should be not that hard when creating the difference based on the
    requirements - but also the topics must be included)
o Translations / Intenationalization
  - Input: possible define a new set of tags - one for each language.
o Topic includereqs: There is the need to at least specify ONE
  requirement which is located before all others.
o Add version number to rmtoo -v or something
o Add roadmap feature
o Add ToDo list feature
o History in document: specify two versions and create automatically a
  list of all changed requirements.
o Clean up code (XXX, ToDo, ...)
o Use MemLog instead of print.
o 'The only requirement management tool which comes with the
  requirements for the tool'. 
o A requirement cannot be 'finished' if on of the dependent is not
  finished. 
o Add glossary
o Add man page for glossary
o Add glossary to presentation

Long Term Evolution
===================

Interaction between programs
----------------------------
The *nix base idea is: let one thing do one thing (but this very
well).  Examples: mostly all commands in /bin and /usr/bin.  They
all work on plain text files and every program has exactly one
functionality. 
When looking to mostly all other areas of data processing, the
interaction of different programs is very, very limited - which
depends on the file format.  Complex programs (like office word
processor) work on complex data.  Mostly each program has it's own
file format.  The file format is mostly not interchangeable with other
programs - and if so, it's mostly hard to convert and often some
aspects are lost during conversion.
Another aspect is, that mostly all programs work on the input data in
a way that they think they 'own' the data. When programs cannot deal
with data, they tend to either complain about corrupted input files or
they ignore the unknown parts in the way that when saving the read-in
data in a program those unknown parts are not contained any more.
Others just rename internally used labels and attributes in a way that
it is impossible to find the original elements after one of those
programs worked on them. Example: OpenOffice Calc.

