#!/usr/bin/env python
#
# Requirement Management Toolset
#
# (c) 2010 by flonatel
#
# For licencing details see COPYING
#

import sys
import git
from optparse import OptionParser
from rmtoo.lib.RequirementSet import RequirementSet
from rmtoo.lib.ReqsContinuum import ReqsContinuum
from rmtoo.lib.Modules import Modules

def parse_cmd_line_opts():
    parser = OptionParser()
    parser.add_option("-d", "--directory", dest="directory",
                  help="Directory with requirements")
    parser.add_option("-f", "--file-config", dest="config_file",
                  help="Config file")
    parser.add_option("-m", "--modules-directory", dest="modules_directory",
                  help="Directory with modules")
    parser.add_option("-c", "--create-makefile-dependencies",
                      dest="create_makefile_dependencies",
                      help="Create makefile dependencies")

    (options, args) = parser.parse_args()

    if options.directory==None:
        print("+++ ERROR: no directory option is specified")
        sys.exit(1)

    if options.modules_directory==None:
        # If there is no modules directory given, use the pycentral one.
        options.modules_directory = "/usr/share/pyshared"

    if options.config_file==None:
        print("+++ ERROR: no config_file option is specified")
        sys.exit(1)

    if len(args)>=1:
        options.base_version = args[0]
    else:
        # If nothing is given 'FILES' is assumed.
        options.base_version = "FILES"

    if len(args)>2:
        print("+++ ERROR: too many args")
        sys.exit(1)

    return options

def execute_cmds(opts, mods, config):
    # Checks are allways done - to be sure that e.g. the dependencies
    # are correct.
    try:
        rc = ReqsContinuum(opts.directory, mods, opts, config)
        reqs = rc.base_requirement_set
    except git.errors.GitCommandError, gce:
        print("+++ ERROR: Problem accessing git tree: '%s'" % gce)
        print("    Is the given version correct?");
        return

    # When only the dependencies are needed, output them to the given
    # file. 
    if opts.create_makefile_dependencies!=None:
        rc.create_makefile_dependencies(opts.create_makefile_dependencies)
        return

    # Output everything
    rc.output()

def load_config(opts):
    # Load config file
    # ('execfile' does not work here.)
    f = file(opts.config_file, "r")
    conf_file = f.read()
    exec(conf_file)
    config = Config()
    f.close()
    return config

def main():
    opts = parse_cmd_line_opts()
    config = load_config(opts)
    mods = Modules(opts.modules_directory, opts, config)
    execute_cmds(opts, mods, config)

if __name__=="__main__":
    main()
